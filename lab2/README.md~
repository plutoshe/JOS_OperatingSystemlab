JOS Lab2 Report
====================================
Result
----------------------------
		running JOS: (1.1s) 
		Physical page allocator: OK 
		Page management: OK 
		Kernel page directory: OK 
		Page management 2: OK 
		Score: 70/70

Preparation
-----------------------------------
花了一下午学习了git相关的知识，从之前的lab1，转换了branch到了lab2，并merge了lab1分支，将这部分内容重新commit，push到了我现在个人的repository
Related Macro and Function
------------------------------------
PGSIZE表页大小
PTE_U, PTE_P, PTE_W代表有关权限
PADDR, KADDR分别是返回匹配虚拟地址的物理地址和返回匹配到物理地址的虚拟地址。
PDX(la), PTX(la), PGOFF(la)代表该线性地址的Page Directory Index, Page Table Index, Page Offset 
PTE_ADDR(pte)返回该page的入口
page2pa, pa2page, page2kva这三个函数，
其中page指的是struct PageInfo结构，这3个函数完成了这个结构对物理地址和逻辑地址的相互转换。
Part 1: Physical Page Management
=======
Exercise 1
-----------------------------------
```
Exercise 1. In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).

boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()

check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.
```
由于不像lab1那样有这样那样的提示，所以一开始从ics书开始复习，到操统书的这一部分都浏览了一遍，基本上有了一些了解，从张驰的报告中看到了有关的ppt，
接下来基本上是看注释加了解，边尝试边探索的前进。
需要注意的一点是程序在lab2中全是virtual address，要注意转换
###exercise1解答
mem_init():
```
	pages = (struct PageInfo*) boot_alloc(npages * sizeof(struct PageInfo));
```
boot_alloc():
```
	if (n > 0) {
		void *temp = nextfree;
		nextfree += n;
		nextfree = ROUNDUP(nextfree, PGSIZE);
		return temp;
	} else if (n == 0) {
		return (void*)nextfree;
	}
	return NULL;
```
page_init():
```
	size_t i;
	size_t low = IOPHYSMEM / PGSIZE;	
	size_t top = (PADDR(boot_alloc(0))) / PGSIZE;
	page_free_list = NULL;
	for (i = 0; i < npages; i++) {
		if (i == 0 || (i >= low && i < top)){
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
			continue;
		}
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
```
page_alloc()
```
	if (page_free_list != NULL) {
		if (alloc_flags & ALLOC_ZERO) {

			memset(page2kva(page_free_list), 0, PGSIZE);
		}
		struct PageInfo* temp = page_free_list;
		page_free_list = page_free_list->pp_link;
		return temp;
	}
	return NULL;
```
page_free():
```
	pp->pp_link = page_free_list;
	page_free_list = pp;
```
###exercise1中出现的错误
```
EAX=00000000 EBX=00010094 ECX=000003d4 EDX=000003d5
ESI=00010094 EDI=000f0118 EBP=f0113f88 ESP=f0113f60
EIP=f01010af EFL=00000006 [-----P-] CPL=0 II=0 A20=1 SMM=0 HLT=0
ES =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]
CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]
SS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]
DS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]
FS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]
GS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]
LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT
TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy
GDT= 00007c4c 00000017
IDT= 00000000 000003ff
CR0=80010011 CR2=00000004 CR3=00114000 CR4=00000000
DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000 
DR6=ffff0ff0 DR7=00000400
EFER=0000000000000000
Triple fault. Halting for inspection via QEMU monitor.
```
在mem_init没住主要到首先要对于pages赋值，以为pages已经赋值过了，所以是空指针错误

 
```
kernel panic at kern/pmap.c:502: assertion failed: nfree_extmem > 0
```
没有注意到page_init()中的i++是加PGSIZE，所以对于low和top忘记除PGSIZE了，造成top没有赋值为对应的地址


```
kernel panic at kern/pmap.c:532: assertion failed: pp1 && pp1 != pp0
```
对于page_free_list在page_alloc函数中alloc之后没有到放弃这一个页面，赋值为下一个pp_link

```
kernel panic at kern/pmap.c:570: assertion failed: c[i] == 0
```
从c = page2kva这条语句发现这个问题，从而重新查看了一边pmap.h和mmu.h。弄清处了相关的宏和函数。
发现自己这时候并没有注意到程序中的地址都是逻辑地址。对物理地址，逻辑地址以及struct Pageinfo的这三个东西没有区分清楚，理解透彻，在清0的时候直接使用了page_next_list，然后就发现实际的并没有清0，应该使用page2kva，将对应的P
PageInfo结构转到应有的逻辑地址上。
将page_alloc（）中的memset(page_next_list, 0, PGSIZE)改变成
memset(page2kva(page_next_list), 0, PGSIZE)

Part 2: Virtual Memory
============

exercise 2
--------------------
```
Exercise 2. Look at chapters 5 and 6 of the Intel 80386 Reference Manual, if you haven't done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses paging for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.
```
因为之前复习过ics，另外读了张弛介绍老师的文稿，所以这部分算是比较清楚了

exercise 3
-----------------------
```
Exercise 3. While GDB can only access QEMU's memory by virtual address, it's often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU monitor commands from the lab tools guide, especially the xp command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).

Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.

Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual memory are mapped and with what permissions.
```
我的qemu好像并没有这些个命令，所以直接略过了。
```
Question

Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?
	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;
```
因为the kernel can't sensibly dereference a physical address，所以这个地址是逻辑地址，x的类型应该为uintptr_t.

 

exercise 4
-------------------------------
```
Exercise 4. In the file kern/pmap.c, you must implement code for the following functions.

        pgdir_walk()
        boot_map_region()
        page_lookup()
        page_remove()
        page_insert()
	
check_page(), called from mem_init(), tests your page table management routines. You should make sure it reports success before proceeding.
```

###exercise4解答
pgdir_walk():
```
	bool exist = false;
	pte_t *ptdir;
	if	(pgdir[PDX(va)] & PTE_P) {
		ptdir = (pte_t*) KADDR(PTE_ADDR(pgdir[PDX(va)]));
		return ptdir + PTX(va);
	} else {
		if (create) {
			struct PageInfo * temp = page_alloc(ALLOC_ZERO);
			if (temp == NULL) return NULL;
			temp->pp_ref++;
			pgdir[PDX(va)] = page2pa(temp) | PTE_P | PTE_U | PTE_W;
			ptdir = (pte_t*) KADDR(page2pa(temp));
			return ptdir + PTX(va);
		} else return NULL;
	}
	return NULL;
```
boot_map_region():
```
	uintptr_t end = va + size;
	pte_t* now;
	for (;va != end; va += PGSIZE, pa += PGSIZE) {
		now = pgdir_walk(pgdir, (void*)va, 1);
		if (now == NULL)
			panic("stopped");
		*now = PTE_ADDR(pa) | perm | PTE_P;
	}
```
page_lookup():
```
	pte_t* now = pgdir_walk(pgdir, va, 0);
	if (now != NULL) {
		if (pte_store != NULL) {
			*pte_store = now;
		}
		return pa2page(PTE_ADDR(*now));
	}
	return NULL;
```
page_remove():
```
	pte_t* now;	
	struct PageInfo* temp = page_lookup(pgdir, va, &now);
	if (temp != NULL) {
		if (*now & PTE_P) {
			page_decref(temp);
		}
		*now = 0;
	}

```
page_insert():
```
	pte_t* now = pgdir_walk(pgdir, va, 0);
	if ((now != NULL) && (*now & PTE_P)) {
		if (PTE_ADDR(*now) == page2pa(pp)) {
			*now = PTE_ADDR(page2pa(pp)) | perm | PTE_P;
			return 0;
		}
		page_remove(pgdir, va);
	}
	if (now == NULL) now = pgdir_walk(pgdir, va, 1);
	if (now == NULL) return -E_NO_MEM;
	*now = PTE_ADDR(page2pa(pp)) | perm | PTE_P;
	pp->pp_ref++;
	return 0;
```

###exercise4遇到的困难和错误
由于读到了有关与reference的区别，对于一开始的page_init()函数进行了修改，对于之前那些不能引用的pp_ref设为1。


 
```
kernel panic at kern/pmap.c:354: KADDR called with invalid pa f0119000
```
对于这个错误非常有感触，一开是认为a+4和a[4]是相同的，之后经过考虑，发现如果a是一个int*的话，a+4还是表示一个int指针，而a[4]则是一个int，所以这两者不同，这个错误属于自己对于指针的理解错误，所以对于pgdir_walk中的物理地址没有引用正确导致了这个错误。

 
```
kernel panic at kern/pmap.c:775: assertion failed: !page_alloc(0)
```
在page_insert()函数中没有考虑insert的page跟已有的配对的page相同的情况

 
```
kernel panic at kern/pmap.c:790: assertion failed: *pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U
```
在之前判断insert的page跟已有的配对的相同，我直接return 0了，没有给他这个页的权限重新赋值。


```
kernel panic at kern/pmap.c:821: assertion failed: pp2->pp_ref == 0
```
这里在insert取到的pte_t和remove时取到的pte_t不同，最后发现是在page_lookup中犯了一个指针的常识错误，在对pte_store赋值的时候，我直接使用了下面的语句

```
if (pte_store != NULL) {
	pte_store = &now;
}
```
但实际上应该是
```
if (pte_store != NULL) {
	*pte_store = now;
}
```
我将传入的指针换了一个地址，所以才会出现这个错误。
上面的大部分错误都是对于指针的错误，所以lab1自以为对于指针有了一个很好的理解，其实并没有理解的特别透彻，这次算是给自己重新认识了一遍指针。

Part 3: Kernel Address Space
===========================

Exercise 5
--------------------
```
Exercise 5. Fill in the missing code in mem_init() after the call to check_page().
```
###exercise5解答
```
Map 'pages' read-only by the user at linear address UPAGES
Use the physical memory that 'bootstack' refers to as the kernel stack.  The kernel stack grows down from virtual address KSTACKTOP.
Map all of physical memory at KERNBASE.
Your code should now pass the check_kern_pgdir() and
 check_page_installed_pgdir() checks.

```
根据要求的对应夜页面和权限，得到以下代码:
```
	boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
	boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);
	boot_map_region(kern_pgdir, KERNBASE, /*(1 << 32)*/ - KERNBASE, 0, PTE_W); 

```
###exercise5遇到的困难和错误
```
kernel panic at kern/pmap.c:685: assertion failed: check_va2pa(pgdir, KERNBASE + i) == i
```
这个错误是在boot_map_region中我写的循环没有考虑到尾地址越界的情况，直接使用了< 号，其实应该使用！=号
```
	uintptr_t end = va + size;
	for (;va < end; va += PGSIZE, pa += PGSIZE) 
```
应该改成
```
	uintptr_t end = va + size;
	for (;va ！= end; va += PGSIZE, pa += PGSIZE) {
 
```
###问题解答
```
Question:
What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:
Entry	Base Virtual Address	Points to (logically):
1023	?	Page table for top 4MB of phys memory
1022	?	?
.	?	?
.	?	?
.	?	?
2	0x00800000	?
1	0x00400000	?
0	0x00000000	[see next question]
```

```
Question:
(From Lecture 3) We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?
```
在这一段中我们只给了用户可读的权限，及PTE_U，用户是不被允许修改此处的代码的，从而带到了保护的目的。
```
Question:
What is the maximum amount of physical memory that this operating system can support? Why?
```
根据PTSIZE，算出PGSIZE*NPTENTRIES/sizeof(struct PageInfo)为512KB(sizeof(struct PageInfo)为8kb）,所以每个Page Table对应一个PGSIZE的页大约为2G
```
Question:
How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?
```

```
Question:
Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?
```

Challenge
----------------
```
Challenge! We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the PTE_PS ("Page Size") bit in the page directory entries. This bit was not supported in the original 80386, but is supported on more recent x86 processors. You will therefore have to refer to Volume 3 of the current Intel manuals. Make sure you design the kernel to use this optimization only on processors that support it!
```
查阅了相关资料，感觉重写一个有些困难，所以没有做这个challenge

```
K> setp 0x100000
before change PTE_U : 0 PTE_W : 0 PTE_P : 0 
after change PTE_U : 0 PTE_W : 0 PTE_P : 0 
K> setp 0x1000000 1 1 1
before change PTE_U : 0 PTE_W : 0 PTE_P : 0 
after change PTE_U : 1 PTE_W : 1 PTE_P : 1 
K> setp 0x1000000 0 1 0
before change PTE_U : 1 PTE_W : 1 PTE_P : 1 
after change PTE_U : 0 PTE_W : 1 PTE_P : 0 
```


```
Challenge! Extend the JOS kernel monitor with commands to:

Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual/linear addresses in the currently active address space. For example, you might enter 'showmappings 0x3000 0x5000' to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.
Explicitly set, clear, or change the permissions of any mapping in the current address space.
Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!
Do anything else that you think might be useful later for debugging the kernel. (There's a good chance it will be!)
```

```
Challenge! Write up an outline of how a kernel could be designed to allow user environments unrestricted use of the full 4GB virtual and linear address space. Hint: the technique is sometimes known as "follow the bouncing kernel." In your design, be sure to address exactly what has to happen when the processor transitions between kernel and user modes, and how the kernel would accomplish such transitions. Also describe how the kernel would access physical memory and I/O devices in this scheme, and how the kernel would access a user environment's virtual address space during system calls and the like. Finally, think about and describe the advantages and disadvantages of such a scheme in terms of flexibility, performance, kernel complexity, and other factors you can think of.
```

```
Challenge! Since our JOS kernel's memory management system only allocates and frees memory on page granularity, we do not have anything comparable to a general-purpose malloc/free facility that we can use within the kernel. This could be a problem if we want to support certain types of I/O devices that require physically contiguous buffers larger than 4KB in size, or if we want user-level environments, and not just the kernel, to be able to allocate and map 4MB superpages for maximum processor efficiency. (See the earlier challenge problem about PTE_PS.)
Generalize the kernel's memory allocation system to support pages of a variety of power-of-two allocation unit sizes from 4KB up to some reasonable maximum of your choice. Be sure you have some way to divide larger allocation units into smaller ones on demand, and to coalesce multiple small allocation units back into larger units when possible. Think about the issues that might arise in such a system.
```
 

大标题
===================================
  大标题一般显示工程名,类似html的\<h1\><br />
  你只要在标题下面跟上=====即可

  
中标题
-----------------------------------
  中标题一般显示重点项,类似html的\<h2\><br />
  你只要在标题下面输入------即可
  
### 小标题
  小标题类似html的\<h3\><br />
  小标题的格式如下 ### 小标题<br />
  注意#和标题字符中间要有空格

### 注意!!!下面所有语法的提示我都先用小标题提醒了!!! 

### 单行文本框
    这是一个单行的文本框,只要两个Tab再输入文字即可
        
### 多行文本框  
    这是一个有多行的文本框
    你可以写入代码等,每行文字只要输入两个Tab再输入文字即可
    这里你可以输入一段代码

### 比如我们可以在多行文本框里输入一段代码,来一个Java版本的HelloWorld吧
    public class HelloWorld {

      /**
      * @param args
   */
   public static void main(String[] args) {
   System.out.println("HelloWorld!");

   }

    }
### 链接
1.[点击这里你可以链接到www.google.com](http://www.google.com)<br />
2.[点击这里我你可以链接到我的博客](http://guoyunsky.iteye.com)<br />

###只是显示图片
![github](http://github.com/unicorn.png "github")

###想点击某个图片进入一个网页,比如我想点击github的icorn然后再进入www.github.com
[![image]](http://www.github.com/)
[image]: http://github.com/github.png "github"

### 文字被些字符包围
> 文字被些字符包围
>
> 只要再文字前面加上>空格即可
>
> 如果你要换行的话,新起一行,输入>空格即可,后面不接文字
> 但> 只能放在行首才有效

### 文字被些字符包围,多重包围
> 文字被些字符包围开始
>
> > 只要再文字前面加上>空格即可
>
>  > > 如果你要换行的话,新起一行,输入>空格即可,后面不接文字
>
> > > > 但> 只能放在行首才有效

### 特殊字符处理
有一些特殊字符如<,#等,只要在特殊字符前面加上转义字符\即可<br />
你想换行的话其实可以直接用html标签\<br /\>
